buildscript {
	repositories {
		maven { url 'https://maven.quiltmc.org/repository/release' }
	}

	dependencies {
		classpath libs.quilt.parsers.json
	}
}

import org.quiltmc.parsers.json.JsonReader
import org.quiltmc.parsers.json.JsonWriter

import java.nio.file.Files

plugins {
    id 'maven-publish'
	id 'org.jetbrains.gradle.plugin.idea-ext' version '1.1.6'
    alias libs.plugins.quilt.loom
}

base {
    archivesName = project.archives_base_name
}

version = "$project.version+${libs.versions.minecraft.get()}"
group = project.maven_group

allprojects {

    processResources {
        inputs.properties 'version': version, 'group': project.group

        filesMatching('quilt.mod.json') {
            expand 'version': version, 'group': project.group
        }
    }
}

allprojects {

    apply plugin: 'org.quiltmc.loom'

    repositories {
        // Add repositories to retrieve artifacts from in here.
        // You should only use this when depending on other mods because
        // Loom adds the essential maven repositories to download Minecraft and libraries from automatically.
        // See https://docs.gradle.org/current/userguide/declaring_repositories.html
        // for more information about repositories.
    }

    // All the dependencies are declared at gradle/libs.version.toml and referenced with "libs.<id>"
    // See https://docs.gradle.org/current/userguide/platforms.html for information on how version catalogs work.
    dependencies {
        minecraft libs.minecraft
        mappings variantOf(projectLibs.quilt.mappings) { classifier 'intermediary-v2' }

        modImplementation libs.quilt.loader

        modImplementation libs.quilted.fabric.api
    }

    tasks.withType(JavaCompile).configureEach {
        it.options.encoding = 'UTF-8'
        // Minecraft 1.18 (1.18-pre2) upwards uses Java 17.
        it.options.release = 17
    }

	def generateQmj = tasks.register("generateQmj", GenerateQMJ) {
		it.inputDir.set(project.file("qmj_resources/"))
		it.outputDir.set(project.file("build/generated/generated_resources/"))
		it.projectId.set(project.name.replace("-", "_"))
		it.quiltLoaderVersion.set(libs.versions.quilt.loader.get())
		it.quiltedFabricAPIVersion.set(libs.versions.quilted.fabric.api.get())
		it.minecraftVersion.set(libs.versions.minecraft.get())
	}

	sourceSets {
		main {
			resources {
				srcDir generateQmj
			}
		}
	}

    java {
        // Still required by IDEs such as Eclipse and Visual Studio Code
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17

        withSourcesJar()
        withJavadocJar()
    }

	sourcesJar {
		dependsOn(generateQmj)
	}
}

subprojects {
    afterEvaluate {
        // Disable the gen sources task on sub projects
        genSourcesWithVineflower.enabled = false
        genSourcesWithFernFlower.enabled = false
        genSourcesWithCfr.enabled = false
    }
}

// If you plan to use a different file for the license, don't forget to change the file name here!
jar {
    from('LICENSE') {
        rename { "${it}_${base.archivesName.get()}" }
    }
}

dependencies {
	api include(project(":mmodding-block"))
	api include(project(":mmodding-core"))
	api include(project(":mmodding-feature"))
	api include(project(":mmodding-fluid"))
	api include(project(":mmodding-item"))
	api include(project(":mmodding-worldgen"))
}

afterEvaluate {
	def generateQmjForIdea = tasks.register("generateQmjForIdea")
	generateQmjForIdea.get().dependsOn project.tasks.named("generateQmj")
	project.subprojects.each {
		generateQmjForIdea.get().dependsOn it.tasks.named("generateQmj")
	}

	idea {
		project {
			settings {
				taskTriggers {
					afterSync generateQmjForIdea.get()
				}
			}
		}
	}
}

// Loom can detect content of generated QMJs thanks to that block code.
afterEvaluate {
	subprojects.each {
		project.sourceSets.main.compileClasspath += it.sourceSets.main.compileClasspath
		project.sourceSets.main.runtimeClasspath += it.sourceSets.main.runtimeClasspath
	}
}

// Configure the maven publication
publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
        }
    }

    // See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
    repositories {
        // Add repositories to publish to here.
        // Notice: This block does NOT have the same function as the block in the top level.
        // The repositories here will be used for publishing your artifact, not for
        // retrieving dependencies.
    }
}

abstract class GenerateQMJ extends DefaultTask {

	@InputDirectory
	abstract DirectoryProperty getInputDir()

	@OutputDirectory
	abstract DirectoryProperty getOutputDir()

	@Input
	abstract Property<String> getProjectId()

	@Input
	abstract Property<String> getQuiltLoaderVersion()

	@Input
	abstract Property<String> getQuiltedFabricAPIVersion()

	@Input
	abstract Property<String> getMinecraftVersion()

	@Override
	String getGroup() {
		return "generation"
	}

	@TaskAction
	void generateQmj() throws IOException {

		java.nio.file.Path input = this.getInputDir().getAsFile().get().toPath()

		Map<String, BufferedReader> properties = QmjBuilder.getProperties(input)

		java.nio.file.Path output = this.getOutputDir().getAsFile().get().toPath().resolve("quilt.mod.json")

		if (Files.exists(output)) {
			Files.delete(output)
		}

		String projectName = ""

		this.getProjectId().get().split("_").each {
			if (it[0] == "m" && it[1] == "m") {
				projectName = projectName + it[0].toUpperCase() + it[1].toUpperCase() + it.substring(2) + " "
			}
			else {
				projectName = projectName + it[0].toUpperCase() + it.substring(1) + " "
			}
		}

		projectName = projectName + "Library"

		String projectDescription

		if (this.getProjectId().get() == "mmodding") {
			projectDescription = "Library made by MModding Team to provide few sets of modding tools."
		}
		else {
			projectDescription = projectName - "MModding " + " of MModding"
		}

		QmjBuilder.buildQmj(
			this.getProjectId().get(),
			projectName,
			projectDescription,
			(String) project.version,
			this.getQuiltLoaderVersion().get(),
			this.getQuiltedFabricAPIVersion().get(),
			this.getMinecraftVersion().get(),
			output,
			properties,
			QmjBuilder.hasMixins(input),
			QmjBuilder.hasAccessWideners(input),
			QmjBuilder.getEnvironment(input)
		)
	}
}

final class QmjBuilder {

	static Map<String, BufferedReader> getProperties(java.nio.file.Path path) {
		Map<String, BufferedReader> properties = new HashMap<>()

		File entrypoints = path.resolve("entrypoints.json").toFile()
		if (entrypoints.exists()) {
			properties.put("entrypoints", entrypoints.newReader())
		}

		File injected_interfaces = path.resolve("injected_interfaces.json").toFile()
		if (injected_interfaces.exists()) {
			properties.put("injected_interfaces", injected_interfaces.newReader())
		}

		return properties
	}

	static boolean hasMixins(java.nio.file.Path path) {
		boolean hasMixins = false

		JsonReader reader = JsonReader.json(path.resolve("main.json"))

		reader.beginObject()

		while (reader.hasNext()) {
			if (reader.nextName() == "has_mixins") {
				hasMixins = reader.nextBoolean()
			}
			else {
				reader.skipValue()
			}
		}

		reader.close()

		return hasMixins
	}

	static boolean hasAccessWideners(java.nio.file.Path path) {
		boolean hasAccessWideners = false

		JsonReader reader = JsonReader.json(path.resolve("main.json"))

		reader.beginObject()

		while (reader.hasNext()) {
			if (reader.nextName() == "has_access_wideners") {
				hasAccessWideners = reader.nextBoolean()
			}
			else {
				reader.skipValue()
			}
		}

		reader.close()

		return hasAccessWideners
	}

	static String getEnvironment(java.nio.file.Path path) {
		String environment = "both"

		JsonReader reader = JsonReader.json(path.resolve("main.json"))

		reader.beginObject()

		while (reader.hasNext()) {
			if (reader.nextName() == "environment") {
				environment = reader.nextString()
			}
			else {
				reader.skipValue()
			}
		}

		reader.close()

		return environment
	}

	static void writeEntrypoints(JsonWriter writer, BufferedReader bufferedReader) {
		JsonReader reader = JsonReader.json(bufferedReader)

		writer.name("entrypoints")
		writer.beginObject() // Entrypoints Block Start

		reader.beginObject()
		while (reader.hasNext()) {
			writer.name(reader.nextName()).beginArray()
			reader.beginArray()
			while (reader.hasNext()) {
				writer.value(reader.nextString())
			}
			reader.endArray()
			writer.endArray()
		}
		reader.endObject()

		writer.endObject() // Entrypoints Block End

		reader.close()
	}

	static void writeInjectedInterfaces(JsonWriter writer, BufferedReader bufferedReader) {
		JsonReader reader = JsonReader.json(bufferedReader)

		writer.name("quilt_loom")
		writer.beginObject() // Quilt Loom Block Start

		writer.name("injected_interfaces")
		writer.beginObject() // Quilt Loom Injected Interfaces Block Start

		reader.beginObject()
		while (reader.hasNext()) {
			writer.name(reader.nextName()).beginArray()
			reader.beginArray()
			while (reader.hasNext()) {
				writer.value(reader.nextString().replace(".", "/").replace("\u0024", "\\u0024")) // that way we avoid some errors
			}
			reader.endArray()
			writer.endArray()
		}
		reader.endObject()

		writer.endObject() // Quilt Loom Injected Interfaces Block End

		writer.endObject() // Quilt Loom Block End

		reader.close()
	}

	/*
	 * Wouldn't be possible without the example provided by Quilt Standard Libraries, that are under this license:
	 *
	 * Copyright 2023 The Quilt Project
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	static void buildQmj(
		String projectId,
		String projectName,
		String projectDescription,
		String projectVersion,
		String quiltLoaderVersion,
		String qfapiVersion,
		String minecraftVersion,
		java.nio.file.Path qmjPath,
		Map<String, BufferedReader> qmjProperties,
		boolean hasMixins,
		boolean hasAccessWideners,
		String environment
	) throws IOException {
		JsonWriter writer = JsonWriter.json(qmjPath)

		// Starting by Writing the Basics
		writer.beginObject()
			.name("schema_version").value(1)
			.name("quilt_loader")
			.beginObject() // Quilt Loader Block Start
				.name("group").value("com.mmodding.library")
				.name("id").value(projectId)
				.name("version").value(projectVersion)
				.name("metadata")
				.beginObject() // Quilt Loader MetaData Block Start
					.name("name").value(projectName)
					.name("description").value(projectDescription)
					.name("contributors")
					.beginObject() // Quilt Loader MetaData Contributors Block Start
						.name("MModding Team").value("Owner")
						.name("FirstMegaGame4").value("Author")
					.endObject() // Quilt Loader MetaData Contributors Block End
					.name("contact")
					.beginObject() // Quilt Loader MetaData Contact Block Start
						.name("homepage").value("https://mmodding.github.io")
						.name("issues").value("https://github.com/MModding/mmodding-library/issues")
						.name("sources").value("https://github.com/MModding/mmodding-library")
					.endObject() // Quilt Loader MetaData Contact Block End
					.name("license")
					.beginObject() // Quilt Loader MetaData License Block Start
						.name("name").value("Code: LGPL-3.0\\nAssets: All Rights Reserved")
						.name("id").value("Code-LGPL-3.0-Assets-ARR")
						.name("url").value("../LICENSE")
					.endObject() // Quilt Loader MetaData License Block End
					.name("icon").value("assets/" + projectId + "/icon.png")
				.endObject() // Quilt Loader MetaData Block End
			.name("intermediate_mappings").value("net.fabricmc:intermediary")
			.name("load_type").value("if_possible")
			.name("depends")
			.beginArray() // Depends Block Start
				.beginObject()
					.name("id").value("quilt_loader")
					.name("versions").value(">=" + quiltLoaderVersion)
				.endObject()
				.beginObject()
					.name("id").value("quilted_fabric_api")
					.name("versions").value(">=" + qfapiVersion)
				.endObject()
				.beginObject()
					.name("id").value("minecraft")
					.name("versions").value(">=" + minecraftVersion)
				.endObject()
			.endArray() // Depends Block End
			.name("provides")
			.beginArray() // Provides Block Start

		if (projectId != "mmodding") {
			writer.value(projectId.replace("_", "-"))
		}

		writer.value(projectId + "_library")
				.value(projectId.replace("_", "-") + "-library")
				.value(projectId + "_api")
				.value(projectId.replace("_", "-") + "-api")
			.endArray() // Provides Block End

		if (qmjProperties.containsKey("entrypoints")) {
			writeEntrypoints(writer, qmjProperties.get("entrypoints"))
		}

		writer.endObject() // Quilt Loader Block End

		if (hasMixins) {
			writer.name("mixin").value(projectId + ".mixins.json")
		}

		if (hasAccessWideners) {
			writer.name("access_widener").value(projectId + ".accesswidener")
		}

		Runnable environmentWriter = () -> writer.name("minecraft").beginObject().name("environment").value(environment).endObject()

		if (environment.equalsIgnoreCase("client") || environment.equalsIgnoreCase("server")) {
			environmentWriter.run()
		}

		writer.name("modmenu")
			.beginObject() // ModMenu Block Start
				.name("badges")
				.beginArray()
					.value("library")
				.endArray()
				.name("parent")
					.beginObject() // ModMenu Parent Block Start
						.name("id").value("mmodding")
						.name("name").value("MModding Library")
						.name("description").value("Library made by MModding Team to provide few sets of modding tools.")
						.name("icon").value("assets/" + projectId + "/icon.png")
						.name("badges")
						.beginArray()
							.value("library")
						.endArray()
					.endObject() // ModMenu Parent Block End
			.endObject() // ModMenu Block End

		if (qmjProperties.containsKey("injected_interfaces")) {
			writeInjectedInterfaces(writer, qmjProperties.get("injected_interfaces"))
		}

		// Ending
		writer.endObject()
		writer.flush()
		writer.close()
	}
}
