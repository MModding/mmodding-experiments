import com.mmodding.gradle.api.mod.json.NamespaceProvider;
import com.mmodding.gradle.api.mod.json.ParentSchema;

plugins {
    id 'maven-publish'
    alias libs.plugins.fabric.loom
	alias libs.plugins.mmodding.gradle
}

base {
    archivesName = project.archives_base_name
}

version = "$project.version+${libs.versions.minecraft.get()}"
group = project.maven_group

static def getMModdingLibraryNamespace(Project project) {
	return project.name.replace("-", "_")
}

static def getMModdingLibraryName(Project project) {
	String projectName = ""
	getMModdingLibraryNamespace(project).split("_").each {
		if (it[0] == "m" && it[1] == "m") {
			projectName = projectName + it[0].toUpperCase() + it[1].toUpperCase() + it.substring(2) + " "
		}
		else {
			projectName = projectName + it[0].toUpperCase() + it.substring(1) + " "
		}
	}
	return projectName + "Library"
}

static def getMModdingLibraryDescription(Project project) {
	if (getMModdingLibraryNamespace(project) == "mmodding") {
		return "Library made by MModding Team to provide few sets of modding tools."
	}
	else {
		return getMModdingLibraryName(project) - "MModding " + " of MModding"
	}
}

static def applyMModdingLibraryProvider(Project project, NamespaceProvider provider) {
	String projectId = getMModdingLibraryNamespace(project);
	if (projectId != "mmodding") {
		provider.provide(projectId.replace("_", "-"))
	}
	provider.provide(projectId + "_library")
	provider.provide(projectId.replace("_", "-") + "-library")
	provider.provide(projectId + "_api")
	provider.provide(projectId.replace("_", "-") + "-api")
}

static def applyYumiCommonsParent(ParentSchema parent) {
	parent.name = "Yumi Commons"
	parent.description = "A library containing common utilities."
	parent.addBadge("library")
}

allprojects {

    processResources {
        inputs.properties 'version': version

        filesMatching('fabric.mod.json') {
            expand 'version': version
        }
    }
}

allprojects {

    apply plugin: 'fabric-loom'
	apply plugin: 'com.mmodding.gradle'

    repositories {
		maven {
			name "QuiltMC"
			url "https://maven.quiltmc.org/repository/release"
		}
		maven {
			name "ParchmentMC"
			url "https://maven.parchmentmc.org"
		}
    }

    // All the dependencies are declared at gradle/libs.version.toml and referenced with "libs.<id>"
    // See https://docs.gradle.org/current/userguide/platforms.html for information on how version catalogs work.
    dependencies {
        minecraft libs.minecraft
		mappings libs.yarn.mappings

		modImplementation libs.fabric.loader

		modImplementation libs.yumi.commons

        modImplementation libs.fabric.api
    }

    tasks.withType(JavaCompile).configureEach {
        it.options.encoding = 'UTF-8'
        // Minecraft 1.18 (1.18-pre2) upwards uses Java 17.
        it.options.release = 17
    }

	mmodding {
		configureFabricModJson {
			name = getMModdingLibraryName(project)
			namespace = getMModdingLibraryNamespace(project)
			description = getMModdingLibraryDescription(project)
			license = "Code: PolyForm-Shield-1.0.0\\nAssets: All Rights Reserved"
			icon = "assets/" + getMModdingLibraryNamespace(project) + "/icon.png"
			addAuthor("MModding Team")
			addContributor("FirstMegaGame4")
			withContact {
				it.homepage = "https://mmodding.com"
				it.sources = "https://github.com/MModding/mmodding-library"
				it.issues = "https://github.com/MModding/mmodding-library/issues"
			}
			withDependencies {
				it.javaVersion = ">=" + 17
				it.minecraftVersion = "~" + libs.versions.minecraft.get()
				it.fabricLoaderVersion = ">=" + libs.versions.fabric.loader.get()
				it.fabricApiVersion = ">=" + libs.versions.fabric.api.get()
			}
			withProvider {
				applyMModdingLibraryProvider(project, it)
			}
			if (getMModdingLibraryNamespace(project) != "mmodding") withParent("mmodding")
			withCustom {
				it.withBlock("modmenu") {
					it.withArray("badges") {
						it.addUnique("library")
					}
				}
			}
		}
	}

    java {
        // Still required by IDEs such as Eclipse and Visual Studio Code
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17

        withSourcesJar()
        withJavadocJar()
    }
}

subprojects {
    afterEvaluate {
        // Disable the gen sources task on sub projects
        genSourcesWithVineflower.enabled = false
        genSourcesWithFernFlower.enabled = false
        genSourcesWithCfr.enabled = false
    }
}

// If you plan to use a different file for the license, don't forget to change the file name here!
jar {
    from('LICENSE.md') {
        rename { "${it}_${base.archivesName.get()}" }
    }
}

mmodding {
	modules(project) {
		it.include {
			it.api("mmodding-block")
			it.api("mmodding-block-entity")
			it.api("mmodding-config")
			it.api("mmodding-core")
			it.api("mmodding-datagen")
			it.api("mmodding-enchantment")
			it.api("mmodding-fluid")
			it.api("mmodding-item")
			it.api("mmodding-java")
			it.api("mmodding-math")
			it.api("mmodding-network")
			it.api("mmodding-worldgen")
		}
	}
}

dependencies {
	mmodding.configureFMJForDependency(include(libs.yumi.commons.core.get())) {
		name = "Yumi Commons: Core"
		namespace = "yumi-commons-core"
		withContact {
			it.email = "email@yumi.dev"
		}
		addAuthor("LambdAurora") {
			withContact {
				it.email = "email@lambdaurora.dev"
			}
		}
		withParent("yumi-commons") {
			applyYumiCommonsParent(it)
		}
	}

	mmodding.configureFMJForDependency(include(libs.yumi.commons.collections.get())) {
		name = "Yumi Commons: Collections"
		namespace = "yumi-commons-collections"
		withContact {
			it.email = "email@yumi.dev"
		}
		addAuthor("LambdAurora") {
			withContact {
				it.email = "email@lambdaurora.dev"
			}
		}
		withParent("yumi-commons") {
			applyYumiCommonsParent(it)
		}
	}

	mmodding.configureFMJForDependency(include(libs.yumi.commons.event.get())) {
		name = "Yumi Commons: Event"
		namespace = "yumi-commons-event"
		withContact {
			it.email = "email@yumi.dev"
		}
		addAuthor("LambdAurora") {
			withContact {
				it.email = "email@lambdaurora.dev"
			}
		}
		withParent("yumi-commons") {
			applyYumiCommonsParent(it)
		}
	}

	include libs.quilt.parsers.json
}

// Loom can detect content of generated FMJs thanks to that block code.
afterEvaluate {
	project.subprojects.each {
		project.sourceSets.main.compileClasspath += it.sourceSets.main.compileClasspath
		project.sourceSets.main.runtimeClasspath += it.sourceSets.main.runtimeClasspath
	}
}

// Javadocs
allprojects {
	javadoc {
		options {
			it.source = "17"
			it.encoding = "UTF-8"
			it.charSet = "UTF-8"
			it.memberLevel = JavadocMemberLevel.PACKAGE
			it.tags("apiNote:a:API Note:", "implNote:a:Implementation Note:")
			it.addStringOption('Xdoclint:none', '-quiet')
		}

		allprojects.each {
			source(it.sourceSets.main.allJava)
			files(it.sourceSets.main.compileClasspath)
		}

		include("**/api/**")
		// failOnError true => seems to have class load issues that prevents javadocs from working well with this, needs investigation in the future
	}
}

// Configure the maven publication
allprojects {

	apply plugin: 'maven-publish'

	afterEvaluate {
		publishing {
			publications {
				mavenJava(MavenPublication) {
					from components.java
				}
			}

			// See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
			repositories {
				// Add repositories to publish to here.
				// Notice: This block does NOT have the same function as the block in the top level.
				// The repositories here will be used for publishing your artifact, not for
				// retrieving dependencies.
			}
		}
	}
}
